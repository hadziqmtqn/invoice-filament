<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Carbon;
use Illuminate\Support\Str;

class RecurringInvoice extends Model
{
    protected $fillable = [
        'slug',
        'invoice_number',
        'serial_number',
        'code',
        'user_id',
        'title',
        'date',
        'due_date',
        'recurrence_frequency',
        'repeat_every',
        'discount',
        'note',
        'status',
        'start_generate_date',
        'last_generated_date'
    ];

    protected function casts(): array
    {
        return [
            'slug' => 'string',
            'date' => 'datetime',
            'due_date' => 'datetime',
            'start_generate_date' => 'datetime',
            'last_generated_date' => 'datetime'
        ];
    }

    protected static function boot(): void
    {
        parent::boot(); // TODO: Change the autogenerated stub

        static::creating(function (RecurringInvoice $recurringInvoice) {
            $recurringInvoice->slug = Str::uuid()->toString();
            $recurringInvoice->invoice_number = time();
            $recurringInvoice->serial_number = self::max('serial_number') + 1;
            $recurringInvoice->code = 'RINV' . Str::upper(Str::random(6)) . '-' . $recurringInvoice->serial_number;
            $recurringInvoice->start_generate_date = $recurringInvoice->next_invoice_date;
        });
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function lineItems(): HasMany
    {
        return $this->hasMany(LineItem::class, 'recurring_invoice_id');
    }

    public function getRouteKeyName(): string
    {
        return 'slug';
    }

    protected function totalPrice(): Attribute
    {
        $totalPrice = $this->lineItems->sum(function ($item) {
            return $item->qty * $item->rate;
        });
        $discountAmount = ($totalPrice * $this->discount) / 100;
        $totalPrice -= $discountAmount;

        return Attribute::make(
            get: fn() => $totalPrice,
        );
    }

    protected function nextInvoiceDate(): Attribute
    {
        return Attribute::make(function () {
            // Fallback jika last_generated_date kosong
            $baseDate = Carbon::parse($this->date); // fallback terakhir

            $date = $baseDate->copy();
            $now = now();

            $repeatEvery = (int) ($this->repeat_every ?: 1);

            $i = 0; // batas iterasi agar aman dari infinite loop
            while ($date <= $now && $i < 100) {
                $date = match ($this->recurrence_frequency) {
                    'seconds' => $date->addSeconds($repeatEvery),
                    'minutes' => $date->addMinutes($repeatEvery),
                    'days' => $date->addDays($repeatEvery),
                    'weeks' => $date->addWeeks($repeatEvery),
                    'months' => $date->addMonths($repeatEvery),
                    'years' => $date->addYears($repeatEvery),
                    default => $date,
                };
                $i++;
            }

            return $date;
        });
    }
}
